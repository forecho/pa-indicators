//@version=6
indicator("PA Indicators", overlay=true, max_labels_count=500, max_boxes_count=500)

// ===== å‚æ•°è®¾ç½® =====
string grp_ema = "EMA è®¾ç½®"
ema20Length = input.int(20, "EMA20", minval=1, group=grp_ema)
ema240Length = input.int(240, "EMA240", minval=1, group=grp_ema)

string grp_kcounter = "Kçº¿è®¡æ•°å™¨è®¾ç½®"
showBarCount = input.bool(true, "Kçº¿è®¡æ•°", group=grp_kcounter)
intervalCount = input.bool(true, "é—´éš”è®¡æ•°", group=grp_kcounter)
rthSession = input.session("0930-1615", "RTH(ç¾ä¸œæ—¶é—´)", group=grp_kcounter)
textSize = input.string("small", "æ–‡å­—å¤§å°", options=["tiny", "small", "normal", "large"], group=grp_kcounter)
textColor = input.color(color.new(color.purple, 5), "æ–‡å­—é¢œè‰²", group=grp_kcounter)

// IBS é¢œè‰²è®¾ç½®
string grp_ibs_color = "IBS é¢œè‰²è®¾ç½®"
baseBullColor = input.color(#26A69A, "é˜³çº¿åŸºç¡€é¢œè‰²", group=grp_ibs_color)
baseBearColor = input.color(#EF5350, "é˜´çº¿åŸºç¡€é¢œè‰²", group=grp_ibs_color)
rangeColor = input.color(color.new(#2196F3, 50), "åŒºé—´éœ‡è¡é¢œè‰²", group=grp_ibs_color)
wickThreshold = input.float(50, "å½±çº¿é˜ˆå€¼(%)", minval=0, maxval=100, step=5, group=grp_ibs_color, tooltip="å½±çº¿è¶…è¿‡æ­¤ç™¾åˆ†æ¯”æ—¶æ˜¾ç¤ºä¸ºåŒºé—´éœ‡è¡(è“è‰²)")

// IBS é€æ˜åº¦æ¸å˜ï¼šå¼ºåŠ¿(0%) â†’ æ™®é€š(30%) â†’ å¼±åŠ¿(85%)
color strongBullColor = color.new(baseBullColor, 0)    // å®è‰²
color strongBearColor = color.new(baseBearColor, 0)    // å®è‰²
color normalBullColor = color.new(baseBullColor, 30)   // ç¨é€æ˜
color normalBearColor = color.new(baseBearColor, 30)   // ç¨é€æ˜
color weakBullColor = color.new(baseBullColor, 85)     // å¾ˆæ·¡
color weakBearColor = color.new(baseBearColor, 85)     // å¾ˆæ·¡

// ç¼ºå£æ£€æµ‹è®¾ç½®
string grp_gap = "ç¼ºå£æ£€æµ‹è®¾ç½®"
enableGapDetection = input.bool(true, "å¯ç”¨ç¼ºå£æ£€æµ‹", group=grp_gap)

// L/H æ ‡è®°è®¾ç½®
string grp_lh = "L/H æ ‡è®°è®¾ç½®"
enableLH = input.bool(true, "å¯ç”¨ L/H æ ‡è®°", group=grp_lh)
swingLength = input.int(3, "æ‘†åŠ¨å‘¨æœŸ", minval=1, maxval=10, group=grp_lh, tooltip="æ£€æµ‹é«˜ä½ç‚¹çš„å·¦å³Kçº¿æ•°é‡")
lhTextSize = input.string("small", "æ–‡å­—å¤§å°", options=["tiny", "small", "normal", "large"], group=grp_lh)
lColor = input.color(color.green, "L é¢œè‰²", group=grp_lh)
hColor = input.color(color.red, "H é¢œè‰²", group=grp_lh)
trendMethod = input.string("EMA20", "è¶‹åŠ¿åˆ¤æ–­", options=["EMA20", "EMA20/240"], group=grp_lh, tooltip="EMA20: ä»·æ ¼åœ¨EMA20ä¸Šæ–¹ä¸ºä¸Šå‡è¶‹åŠ¿\nEMA20/240: EMA20åœ¨EMA240ä¸Šæ–¹ä¸ºä¸Šå‡è¶‹åŠ¿")

// B1 æç¤ºè®¾ç½®
string grp_b1 = "B1 æç¤ºè®¾ç½®"
enableB1Hint = input.bool(true, "æ˜¾ç¤º B1 æç¤º", group=grp_b1)
gapThreshold = input.float(0.3, "è·³ç©ºé˜ˆå€¼(%)", minval=0.1, maxval=2, step=0.1, group=grp_b1, tooltip="é«˜å¼€/ä½å¼€çš„åˆ¤å®šé˜ˆå€¼")

// ===== EMA =====
ema20 = ta.ema(close, ema20Length)
ema240 = ta.ema(close, ema240Length)
plot(ema20, "EMA20", color=color.green, linewidth=1)
plot(ema240, "EMA240", color=color.yellow, linewidth=1)

// ===== è¶‹åŠ¿åˆ¤æ–­ =====
bool isUptrend = trendMethod == "EMA20" ? close > ema20 : ema20 > ema240
bool isDowntrend = trendMethod == "EMA20" ? close < ema20 : ema20 < ema240

// ================================================================= //
// ===== IBS Kçº¿ç€è‰² + åŒºé—´éœ‡è¡æ£€æµ‹ =====
// ================================================================= //

// 1. è®¡ç®—IBSå€¼
float rangePrice = high - low
float ibs = rangePrice > 0 ? (close - low) / rangePrice * 100 : 50

// 2. è®¡ç®—å½±çº¿é•¿åº¦å æ¯”
float upperWick = high - math.max(open, close)  // ä¸Šå½±çº¿
float lowerWick = math.min(open, close) - low   // ä¸‹å½±çº¿
float upperWickPercent = rangePrice > 0 ? (upperWick / rangePrice * 100) : 0
float lowerWickPercent = rangePrice > 0 ? (lowerWick / rangePrice * 100) : 0

// 3. åˆ¤æ–­æ˜¯å¦ä¸ºåŒºé—´éœ‡è¡Kçº¿ï¼ˆä»»ä¸€å½±çº¿è¶…è¿‡é˜ˆå€¼ï¼‰
bool isRangeBar = upperWickPercent > wickThreshold or lowerWickPercent > wickThreshold

// 4. æ ¸å¿ƒé€»è¾‘
isBullBar = close >= open

color bar_color = na

// ä¼˜å…ˆåˆ¤æ–­ï¼šå¦‚æœæ˜¯åŒºé—´éœ‡è¡Kçº¿ï¼Œç›´æ¥ç”¨è“è‰²
if isRangeBar
    bar_color := rangeColor
else
    // å¦åˆ™æŒ‰IBSé€»è¾‘ç€è‰²
    if isBullBar
        if ibs > 69
            bar_color := strongBullColor
        else if ibs < 31
            bar_color := weakBullColor
        else
            bar_color := normalBullColor
    else
        if ibs < 31
            bar_color := strongBearColor
        else if ibs > 69
            bar_color := weakBearColor
        else
            bar_color := normalBearColor

// 5. åº”ç”¨é¢œè‰²
barcolor(bar_color)

// ================================================================= //
// ===== L/H æ‘†åŠ¨é«˜ä½ç‚¹æ ‡è®°ï¼ˆå¸¦ç¼–å·ï¼Œåˆ›æ–°é«˜/ä½é‡ç½®ï¼‰=====
// ================================================================= //

// æ£€æµ‹æ‘†åŠ¨é«˜ç‚¹å’Œä½ç‚¹ï¼ˆä½¿ç”¨ ta.pivothigh/pivotlowï¼Œç¡®è®¤åæ ‡è®°ï¼‰
swingHigh = ta.pivothigh(high, swingLength, swingLength)
swingLow = ta.pivotlow(low, swingLength, swingLength)

// è·å–æ–‡å­—å¤§å°
lhSize = lhTextSize == "tiny" ? size.tiny :
         lhTextSize == "small" ? size.small :
         lhTextSize == "normal" ? size.normal :
         size.large

// è¿½è¸ªè®¡æ•°å’Œæå€¼
var int lCount = 0           // L è®¡æ•°
var int hCount = 0           // H è®¡æ•°
var float highestHigh = na   // ä¸Šå‡è¶‹åŠ¿ä¸­çš„æœ€é«˜ç‚¹ï¼ˆç”¨äºæ£€æµ‹æ–°é«˜ï¼‰
var float lowestLow = na     // ä¸‹é™è¶‹åŠ¿ä¸­çš„æœ€ä½ç‚¹ï¼ˆç”¨äºæ£€æµ‹æ–°ä½ï¼‰
var bool wasUptrend = false  // ä¸Šä¸€æ ¹Kçº¿çš„è¶‹åŠ¿çŠ¶æ€

// è¶‹åŠ¿åˆ‡æ¢æ—¶é‡ç½®
if enableLH
    // æ£€æµ‹è¶‹åŠ¿åˆ‡æ¢
    bool trendChanged = (isUptrend and not wasUptrend) or (isDowntrend and wasUptrend)
    
    if trendChanged
        lCount := 0
        hCount := 0
        highestHigh := high
        lowestLow := low
    
    wasUptrend := isUptrend
    
    // ä¸Šå‡è¶‹åŠ¿é€»è¾‘
    if isUptrend
        // æ£€æµ‹åˆ›æ–°é«˜ â†’ é‡ç½® L è®¡æ•°
        if high > highestHigh or na(highestHigh)
            highestHigh := high
            lCount := 0
        
        // æ£€æµ‹åˆ°æ‘†åŠ¨ä½ç‚¹
        if not na(swingLow) and isUptrend[swingLength]
            lCount := lCount + 1
            label.new(
                 x=bar_index - swingLength,
                 y=low[swingLength],
                 text="L" + str.tostring(lCount),
                 style=label.style_label_up,
                 color=color.new(lColor, 80),
                 textcolor=lColor,
                 size=lhSize
                 )
    
    // ä¸‹é™è¶‹åŠ¿é€»è¾‘
    if isDowntrend
        // æ£€æµ‹åˆ›æ–°ä½ â†’ é‡ç½® H è®¡æ•°
        if low < lowestLow or na(lowestLow)
            lowestLow := low
            hCount := 0
        
        // æ£€æµ‹åˆ°æ‘†åŠ¨é«˜ç‚¹
        if not na(swingHigh) and isDowntrend[swingLength]
            hCount := hCount + 1
            label.new(
                 x=bar_index - swingLength,
                 y=high[swingLength],
                 text="H" + str.tostring(hCount),
                 style=label.style_label_down,
                 color=color.new(hColor, 80),
                 textcolor=hColor,
                 size=lhSize
                 )

// ===== Kçº¿è®¡æ•° =====
currentTfMinutes = timeframe.in_seconds() / 60
inTimeRange = currentTfMinutes >= 5 and currentTfMinutes <= 60

var int barNumber = 0

if showBarCount and inTimeRange
    
    bool isInRth = not na(time(timeframe.period, rthSession, "America/New_York"))
    bool isNewDay = ta.change(time("D")) != 0
    bool isRthFirstBar = isNewDay and isInRth
    
    if isRthFirstBar
        barNumber := 1
    else if isInRth
        barNumber := barNumber + 1
    else
        barNumber := 0
    
    if barNumber > 0
        bool shouldDisplay = not intervalCount or (intervalCount and barNumber % 2 != 0)
        
        if shouldDisplay
            lblSize = textSize == "tiny" ? size.tiny :
              textSize == "small" ? size.small :
              textSize == "normal" ? size.normal :
              size.large

            label.new(
                 x=bar_index, 
                 y=low, 
                 text=str.tostring(barNumber), 
                 style=label.style_none,
                 textcolor=textColor,
                 size=lblSize,
                 yloc=yloc.belowbar
                 )

// ================================================================= //
// ===== å¼€ç›˜æç¤ºï¼ˆå³ä¸Šè§’ï¼‰=====
// ================================================================= //

// ä½¿ç”¨ request.security è·å–å‰ä¸€å¤©æ—¥çº¿æ”¶ç›˜ä»·
prevDayClose = request.security(syminfo.tickerid, "D", close[1], lookahead=barmerge.lookahead_on)
todayOpen = request.security(syminfo.tickerid, "D", open, lookahead=barmerge.lookahead_on)

// è®¡ç®—ä»Šæ—¥è·³ç©ºç™¾åˆ†æ¯”
float todayGapPercent = not na(prevDayClose) and prevDayClose != 0 ? (todayOpen - prevDayClose) / prevDayClose * 100 : 0
bool isGapUp = todayGapPercent > gapThreshold
bool isGapDown = todayGapPercent < -gapThreshold

// åœ¨å³ä¸Šè§’æ˜¾ç¤ºæç¤º
var table hintTable = table.new(position.top_right, 1, 5, bgcolor=color.new(color.black, 30))

// äº®è‰²æ–‡å­—ï¼ˆæ·±è‰²èƒŒæ™¯ä¸‹æ¸…æ™°å¯è§ï¼‰
color brightGreen = #00FF7F   // äº®ç»¿
color brightRed = #FF6B6B     // äº®çº¢
color brightYellow = #FFD700  // é‡‘é»„
color brightWhite = #FFFFFF   // ç™½è‰²

if enableB1Hint and barstate.islast
    string gapPctText = str.tostring(math.abs(todayGapPercent), "#.##") + "%"
    
    if isGapUp
        // é«˜å¼€çš„ 4 ç§æƒ…å†µ
        table.cell(hintTable, 0, 0, "â¬†ï¸ é«˜å¼€ " + gapPctText, text_color=brightGreen, text_size=size.large)
        table.cell(hintTable, 0, 1, "ğŸ“ˆ åŒåº•(EMAé™„è¿‘) â†’ ç»§ç»­å‘ä¸Š", text_color=brightGreen, text_size=size.normal)
        table.cell(hintTable, 0, 2, "ğŸ“ˆ æ¥”å½¢åº•(EMAé™„è¿‘) â†’ ç»§ç»­å‘ä¸Š", text_color=brightGreen, text_size=size.normal)
        table.cell(hintTable, 0, 3, "ğŸ“‰ åŒé¡¶ â†’ å‘ä¸‹åè½¬", text_color=brightYellow, text_size=size.normal)
        table.cell(hintTable, 0, 4, "ğŸ“‰ æ¥”å½¢é¡¶ â†’ å‘ä¸‹åè½¬", text_color=brightYellow, text_size=size.normal)
    else if isGapDown
        // ä½å¼€çš„ 4 ç§æƒ…å†µ
        table.cell(hintTable, 0, 0, "â¬‡ï¸ ä½å¼€ " + gapPctText, text_color=brightRed, text_size=size.large)
        table.cell(hintTable, 0, 1, "ğŸ“‰ åŒé¡¶(EMAé™„è¿‘) â†’ ç»§ç»­å‘ä¸‹", text_color=brightYellow, text_size=size.normal)
        table.cell(hintTable, 0, 2, "ğŸ“‰ æ¥”å½¢é¡¶(EMAé™„è¿‘) â†’ ç»§ç»­å‘ä¸‹", text_color=brightYellow, text_size=size.normal)
        table.cell(hintTable, 0, 3, "ğŸ“ˆ åŒåº• â†’ å‘ä¸Šåè½¬", text_color=brightGreen, text_size=size.normal)
        table.cell(hintTable, 0, 4, "ğŸ“ˆ æ¥”å½¢åº• â†’ å‘ä¸Šåè½¬", text_color=brightGreen, text_size=size.normal)
    else
        // å¹³å¼€
        table.cell(hintTable, 0, 0, "â¡ï¸ å¹³å¼€ " + gapPctText, text_color=brightWhite, text_size=size.large)

// ================================================================= //
// ===== ç¼ºå£æ£€æµ‹åŠŸèƒ½ =====
// ================================================================= //

// å›ºå®šé…ç½®
MAX_LOOKBACK = 2
GAP_UP_COLOR = color.new(color.green, 40)
GAP_DOWN_COLOR = color.new(color.red, 40)
MEASURING_UP_COLOR = color.new(color.green, 70)
MEASURING_DOWN_COLOR = color.new(color.red, 70)
DELETE_FILLED = true

// æ•°æ®ç»“æ„
type Gap
    box boxId
    float top
    float bottom
    bool isUp
    bool isMeasuring

var array<Gap> gaps = array.new<Gap>()

// æ—¶é—´å˜é‡ï¼ˆé¿å…é‡ç»˜è­¦å‘Šï¼‰
newDayET = ta.change(time("D", "America/New_York"))
isCurrentNewDay = newDayET != 0
isPrev1NewDay = ta.change(time("D", "America/New_York"))[1] != 0
isPrev2NewDay = ta.change(time("D", "America/New_York"))[2] != 0

// å·¥å…·å‡½æ•°ï¼šæ£€æŸ¥ç¼ºå£æ˜¯å¦é‡å 
gapsOverlap(float top1, float bottom1, float top2, float bottom2) =>
    not (bottom1 >= top2 or bottom2 >= top1)

// ä¸»é€»è¾‘
if enableGapDetection and barstate.isconfirmed
    
    // --- 1. å…ˆæ£€æµ‹æµ‹é‡å‹ç¼ºå£ï¼ˆè·¨è¶Š2æ ¹Kçº¿çš„å¤§ç¼ºå£ï¼‰---
    if bar_index >= 2
        // åªæœ‰å½“è¿™3æ ¹Kçº¿éƒ½ä¸æ˜¯æ–°äº¤æ˜“æ—¥çš„ç¬¬ä¸€æ ¹æ—¶ï¼Œæ‰æ£€æµ‹æµ‹é‡å‹ç¼ºå£
        bool canDetectMeasuring = not isCurrentNewDay and not isPrev1NewDay and not isPrev2NewDay
        
        if canDetectMeasuring
            bool hasMeasuring = false
            float measuringTop = na
            float measuringBottom = na
            bool isUpMeasuring = false
            
            // å‘ä¸Šæµ‹é‡å‹ç¼ºå£ï¼šå½“å‰Kçº¿æœ€ä½ç‚¹ > å‰2æ ¹Kçº¿æœ€é«˜ç‚¹
            if low > high[2]
                hasMeasuring := true
                measuringTop := low
                measuringBottom := high[2]
                isUpMeasuring := true
            
            // å‘ä¸‹æµ‹é‡å‹ç¼ºå£ï¼šå½“å‰Kçº¿æœ€é«˜ç‚¹ < å‰2æ ¹Kçº¿æœ€ä½ç‚¹
            else if high < low[2]
                hasMeasuring := true
                measuringTop := low[2]
                measuringBottom := high
                isUpMeasuring := false
            
            if hasMeasuring
                // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨ç›¸åŒç¼ºå£
                bool exists = false
                int size = array.size(gaps)
                if size > 0
                    for i = 0 to size - 1
                        g = array.get(gaps, i)
                        if math.abs(g.top - measuringTop) < 0.0001 and math.abs(g.bottom - measuringBottom) < 0.0001
                            exists := true
                            break
                
                if not exists
                    // æ ¹æ®æ–¹å‘é€‰æ‹©é¢œè‰²ï¼ˆæ— è¾¹æ¡†ï¼‰
                    color measuringColor = isUpMeasuring ? MEASURING_UP_COLOR : MEASURING_DOWN_COLOR
                    
                    newBox = box.new(bar_index - 2, measuringTop, bar_index, measuringBottom, 
                                   bgcolor=measuringColor, border_color=na)
                    array.push(gaps, Gap.new(newBox, measuringTop, measuringBottom, isUpMeasuring, true))
    
    // --- 2. æ£€æµ‹æ™®é€šè·³ç©ºç¼ºå£ï¼ˆç›¸é‚»2æ ¹Kçº¿ï¼‰---
    for offset = 1 to MAX_LOOKBACK
        if bar_index >= offset
            bool hasGap = false
            float gapTop = na
            float gapBottom = na
            bool isUpGap = false
            int startBar = bar_index - offset
            
            // å‘ä¸Šç¼ºå£ï¼šå½“å‰Kçº¿æœ€ä½ç‚¹ > å‰offsetæ ¹Kçº¿æœ€é«˜ç‚¹
            if low > high[offset]
                hasGap := true
                gapTop := low
                gapBottom := high[offset]
                isUpGap := true
            
            // å‘ä¸‹ç¼ºå£ï¼šå½“å‰Kçº¿æœ€é«˜ç‚¹ < å‰offsetæ ¹Kçº¿æœ€ä½ç‚¹
            else if high < low[offset]
                hasGap := true
                gapTop := low[offset]
                gapBottom := high
                isUpGap := false
            
            // ç»˜åˆ¶ç¼ºå£
            if hasGap
                // æ£€æŸ¥æ˜¯å¦ä¸æµ‹é‡å‹ç¼ºå£é‡å ï¼ˆæµ‹é‡å‹ç¼ºå£ä¼˜å…ˆï¼‰
                bool overlapsWithMeasuring = false
                int size = array.size(gaps)
                if size > 0
                    for i = 0 to size - 1
                        g = array.get(gaps, i)
                        if g.isMeasuring and gapsOverlap(gapTop, gapBottom, g.top, g.bottom)
                            overlapsWithMeasuring := true
                            break
                
                // å¦‚æœä¸ä¸æµ‹é‡å‹ç¼ºå£é‡å ï¼Œæ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
                if not overlapsWithMeasuring
                    bool exists = false
                    if size > 0
                        for i = 0 to size - 1
                            g = array.get(gaps, i)
                            if math.abs(g.top - gapTop) < 0.0001 and math.abs(g.bottom - gapBottom) < 0.0001
                                exists := true
                                break
                    
                    if not exists
                        color gapColor = isUpGap ? GAP_UP_COLOR : GAP_DOWN_COLOR
                        newBox = box.new(startBar, gapTop, bar_index, gapBottom, bgcolor=gapColor, border_color=na)
                        array.push(gaps, Gap.new(newBox, gapTop, gapBottom, isUpGap, false))

// --- 3. æ£€æŸ¥ç¼ºå£å›è¡¥ ---
if enableGapDetection and DELETE_FILLED
    int size = array.size(gaps)
    if size > 0
        for i = size - 1 to 0
            g = array.get(gaps, i)
            bool isFilled = false
            
            if g.isUp
                // å‘ä¸Šç¼ºå£ï¼šä»·æ ¼å›è½åˆ°ä¸‹è¾¹ç•Œ
                if low <= g.bottom
                    isFilled := true
            else
                // å‘ä¸‹ç¼ºå£ï¼šä»·æ ¼å›å‡åˆ°ä¸Šè¾¹ç•Œ
                if high >= g.top
                    isFilled := true
            
            if isFilled
                box.delete(g.boxId)
                array.remove(gaps, i)